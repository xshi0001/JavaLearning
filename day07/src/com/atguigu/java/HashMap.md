# JavaSenior

## hashmap
HashMap是根据key的hash值决策key放入到哪个桶（bucket）中，通过 `tab=[(n - 1) & hash] `

**问题一：为什么容量总是2的次幂？**

1. 在get方法实现中，实际上是匹配链表中的 Node[] tab 中的数据。
(n - 1) & hash实际上是计算出 key 在 tab 中索引位置，当key的hash没有冲突时，key在HashMap存储的位置就是匹配的node中的第一个节点。如果hash有冲突，就会在node里面节点中查询，直至匹配到相等的key。

2. 因为 n 永远是2的次幂，所以 n-1 通过 二进制表示，永远都是尾端以连续1的形式表示（00001111，00000011）当(n - 1) 和 hash 做与运算时，会保留hash中 后 x 位的 1，
例如 00001111 & 10000011 = 00000011

这样做有2个好处

-  &运算速度快，至少比%取模运算块
- 能保证索引值肯定在 capacity 中，不会超出数组长度
- (n - 1) & hash，当n为2次幂时，会满足一个公式：`(n - 1) & hash = hash % n`
- 那是为了实现均匀分布。因为在使用2的幂的数字的时候，Length-1的值是所有二进制位全为1，这种情况下，index的结果等同于HashCode后几位的值。只要输入的HashCode本身分布均匀，Hash算法的结果就是均匀的。

**问题二： 2.为什么要通过 (n - 1) & hash 决定桶的索引呢？**

- key具体应该在哪个桶中，肯定要和key挂钩的，HashMap顾名思义就是通过hash算法高效的把存储的数据查询出来，所以HashMap的所有get 和 set 的操作都和hash相关。
- 既然是通过hash的方式，那么不可避免的会出现hash冲突的场景。hash冲突就是指 2个key 通过hash算法得出的哈希值是相等的。hash冲突是不可避免的，所以如何尽量避免hash冲突，或者在hash冲突时如何高效定位到数据的真实存储位置就是HashMap中最核心的部分。
- 首先要提的一点是 HashMap 中 capacity 可以在构造函数中指定，如果不指定默认是2 的 (n = 4) 次方，即16。


- HashMap中的hash也做了比较特别的处理，`(h = key.hashCode()) ^ (h >>> 16)`。
先获得key的hashCode的值 h，然后 h 和 h右移16位 做异或运算。
实质上是把一个数的低16位与他的高16位做异或运算，因为在前面 (n - 1) & hash 的计算中，hash变量只有末x位会参与到运算。使高16位也参与到hash的运算能减少冲突。

例如1000000的二进制是 00000000 00001111 01000010 01000000
右移16位： 00000000 00000000 00000000 00001111
异或 00000000 00001111 01000010 01001111

如果当哈希值的高位变化很大，低位变化很小，这样就很容易造成冲
突了，所以这里把高低位都利用起来

**问题三 capacity 永远都是 2 次幂，那么如果我们指定 initialCapacity 不为 2次幂时呢，是不是就破坏了这个规则？**

是不会的，HashMap的tableSizeFor方法做了处理，能保证n永远都是2次幂，
``` java
/**
 * Returns a power of two size for the given target capacity.
 */
static final int tableSizeFor(int cap) {
    //cap-1后，n的二进制最右一位肯定和cap的最右一位不同，即一个为0，一个为1，例如cap=17（00010001），n=cap-1=16（00010000）
    int n = cap - 1;
    //n = (00010000 | 00001000) = 00011000
    n |= n >>> 1;
    //n = (00011000 | 00000110) = 00011110
    n |= n >>> 2;
    //n = (00011110 | 00000001) = 00011111
    n |= n >>> 4;
    //n = (00011111 | 00000000) = 00011111
    n |= n >>> 8;
    //n = (00011111 | 00000000) = 00011111
    n |= n >>> 16;
    //n = 00011111 = 31
    //n = 31 + 1 = 32, 即最终的cap = 32 = 2 的 (n=5)次方
    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
```

问题四：什么时候HashMap会扩容？并且还要描述扩容过程中数据是如何迁移的？


扩容的时候最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。 

“初始容量” 和 “加载因子”。容量 是哈希表中桶的数量，初始容量 只是哈希表在创建时的容量。

触发resize的条件
一：加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。
当哈希表中的条目数超出了加载因子与当前容量的乘积时，

二：并且要存放的位置已经有元素了（hash碰撞），必须满足这两个条件，才要对该哈希表进行 rehash 操作，会将容量扩大为原来两倍。


扩容原理：
扩容：创建一个新的Entry空数组，长度是原数组的2倍。
ReHash：遍历原Entry数组，把所有的Entry重新Hash到新数组。

结论： 
    
    按照原来的拉链法来解决冲突，如果一个桶上的冲突很严重的话，是会导致哈希表
的效率降低至 O（n），而通过红黑树的方式，可以把效率改进至 O（logn）。相比
链式结构的节点，树型结构的节点会占用比较多的空间，所以这是一种以空间换时
间的改进方式。

[HashMap扩容机制以及尾插法](https://blog.csdn.net/fedorafrog/article/details/104448853)
